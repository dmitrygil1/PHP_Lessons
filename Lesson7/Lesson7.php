<?php
// Приведение типов: как пыха отрабатывает строка > int и пр. приколы

$a = [1,2];
$c = "Осьминог";
if ($a == $c) {
    echo "Значения равны, what";
} else {
    echo "Не похоже что значения равны"; // Очевидно, что массив 1,2 не равен "строке", но что будет в случае < или >
}

//Прbведение строки к числу

var_dump((int)"F124salkf2");//0
var_dump((int)"105AFKPGPasda"); //105, т.к. сначала идет число и php его хавает
//т.е. строка приводится к числу если в строка вида 10abc
var_dump("5" == 5); //true, хотя типы данных разные

//Примеры приведения строки в int:
var_dump((int)"10");// 10
var_dump((int)"10abc");// 10
var_dump((int)"10asd10");// 10, если дальше буква - отсекается всё
var_dump((int)"-10");// -10
var_dump((int)"-10asfafAFAF31");// -10
var_dump((int)"-adasdcxAAx10");// -0 = 0, выведет 0
var_dump((int)"0asdgvdf");// 0

//Примеры приведения строки в float:
var_dump((float)"1.5");// 1.5
var_dump((float)"1.5asgdasgd123");// 1.5
var_dump((float)"-1.5.afds");// -1.5.0 = -1.5
var_dump((float)".4#asdfd");// 0.4
var_dump((float)"1,5зааапятая");// 1 и запятую не скушает
var_dump((float)"1.5e10");// 15000000000 потому что (e = 10^10)

//Операции с числом и строкой

var_dump("10"+"10");// 20, несмотря на то, что складываются строки
var_dump("10"+10);// 20, строка преобразуется в int
var_dump("asd"+"asd"); //0, строки из букв не складываются
var_dump(10 + true); // 11 т.к. true = 1

//Сложение массивов
//т.к. в массивае могут быть и числа и строки, то складываются они довольно своеобразно:
$mass1 = [1, "key" => 3,5];
$mass2 = [2, "key" => 2,  3, 4];
var_dump($mass1 + $mass2); // [1,3,5,4] - т.к.. в массиве разные данные

$q = [10,20];
$r = [1,2];
var_dump($q + $r); // 10 b 20